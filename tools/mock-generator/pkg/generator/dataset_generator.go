package generator

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/EduGoGroup/edugo-infrastructure/tools/mock-generator/pkg/parser"
)

type DatasetGenerator struct {
	outputDir string
	tables    map[string]*parser.TableData
}

func NewDatasetGenerator(outputDir string, tables map[string]*parser.TableData) *DatasetGenerator {
	return &DatasetGenerator{
		outputDir: outputDir,
		tables:    tables,
	}
}

func (g *DatasetGenerator) Generate() error {
	// Crear directorio de salida
	if err := os.MkdirAll(g.outputDir, 0755); err != nil {
		return fmt.Errorf("error creando directorio: %w", err)
	}

	// Generar helpers.go (funciones de punteros)
	if err := g.generateHelpers(); err != nil {
		return fmt.Errorf("error generando helpers.go: %w", err)
	}

	// Generar database.go
	if err := g.generateDatabase(); err != nil {
		return fmt.Errorf("error generando database.go: %w", err)
	}

	// Generar tablas
	if err := g.generateTables(); err != nil {
		return fmt.Errorf("error generando tablas: %w", err)
	}

	// Generar loader
	if err := g.generateLoader(); err != nil {
		return fmt.Errorf("error generando loader: %w", err)
	}

	// Formatear código
	if err := g.formatCode(); err != nil {
		fmt.Printf("Warning: no se pudo formatear código: %v\n", err)
	}

	return nil
}

func (g *DatasetGenerator) generateHelpers() error {
	content := `// Code generated by mock-generator. DO NOT EDIT.

package dataset

import "github.com/google/uuid"

// Helper functions for pointer values

func ptrUUID(u uuid.UUID) *uuid.UUID {
	return &u
}

func ptrString(s string) *string {
	return &s
}

func ptrInt(i int) *int {
	return &i
}

func ptrInt64(i int64) *int64 {
	return &i
}

func ptrBool(b bool) *bool {
	return &b
}
`
	filename := filepath.Join(g.outputDir, "helpers.go")
	return os.WriteFile(filename, []byte(content), 0644)
}

// Templates

const databaseTemplate = `// Code generated by mock-generator. DO NOT EDIT.

package dataset

import "sync"

type MockDatabase struct {
{{- range .Tables }}
	{{ .Name }} *{{ .Name }}Table
{{- end }}
	mu sync.RWMutex
}

var DB *MockDatabase

func init() {
	DB = &MockDatabase{
{{- range .Tables }}
		{{ .Name }}: New{{ .Name }}Table(),
{{- end }}
	}
	LoadAllData()
}
`

const tableTemplate = `// Code generated by mock-generator. DO NOT EDIT.

package dataset

import (
	"sync"

	"github.com/EduGoGroup/edugo-infrastructure/postgres/entities"
	"github.com/google/uuid"
)

type {{ .TableCamel }}Table struct {
	data map[uuid.UUID]*entities.{{ .EntityName }}
	list []*entities.{{ .EntityName }}
	mu   sync.RWMutex
}

func New{{ .TableCamel }}Table() *{{ .TableCamel }}Table {
	return &{{ .TableCamel }}Table{
		data: make(map[uuid.UUID]*entities.{{ .EntityName }}),
		list: make([]*entities.{{ .EntityName }}, 0),
	}
}

func (t *{{ .TableCamel }}Table) Add(record *entities.{{ .EntityName }}) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.data[record.ID] = record
	t.list = append(t.list, record)
}

func (t *{{ .TableCamel }}Table) FindByID(id uuid.UUID) *entities.{{ .EntityName }} {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.data[id]
}

func (t *{{ .TableCamel }}Table) List() []*entities.{{ .EntityName }} {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.list
}

func (t *{{ .TableCamel }}Table) Count() int {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return len(t.list)
}
`

const loaderTemplate = `// Code generated by mock-generator. DO NOT EDIT.

package dataset

func LoadAllData() {
{{- range .Tables }}
	load{{ .Name }}()
{{- end }}
}

{{- range .Tables }}

func load{{ .Name }}() {
{{- range .Rows }}
	DB.{{ $.TableName }}.Add(&{{ $.TableCamel }}Record{
{{- range $i, $col := $.Columns }}
		{{ $col }}: {{ index $.RowValues $i }},
{{- end }}
	})
{{- end }}
}
{{- end }}
`

// Generadores

func (g *DatasetGenerator) generateDatabase() error {
	tmpl, err := template.New("database").Parse(databaseTemplate)
	if err != nil {
		return err
	}

	data := struct {
		Tables []struct{ Name string }
	}{
		Tables: g.getTableNames(),
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return err
	}

	filename := filepath.Join(g.outputDir, "database.go")
	return os.WriteFile(filename, buf.Bytes(), 0644)
}

func (g *DatasetGenerator) generateTables() error {
	for tableName, tableData := range g.tables {
		if err := g.generateTable(tableName, tableData); err != nil {
			return err
		}
	}
	return nil
}

func (g *DatasetGenerator) generateTable(tableName string, tableData *parser.TableData) error {
	tmpl, err := template.New("table").Parse(tableTemplate)
	if err != nil {
		return err
	}

	// Convertir columnas a CamelCase
	columns := make([]string, len(tableData.Columns))
	for i, col := range tableData.Columns {
		columns[i] = toCamelCase(col)
	}

	data := struct {
		TableName  string
		TableCamel string
		EntityName string
		Columns    []string
	}{
		TableName:  tableName,
		TableCamel: toCamelCase(tableName),
		EntityName: getEntityName(tableName),
		Columns:    columns,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return err
	}

	filename := filepath.Join(g.outputDir, tableName+"_table.go")
	return os.WriteFile(filename, buf.Bytes(), 0644)
}

// getEntityName convierte nombre de tabla a nombre de entity
func getEntityName(tableName string) string {
	// Mapeo de tablas a entidades
	entityMap := map[string]string{
		"users":           "User",
		"schools":         "School",
		"academic_units":  "AcademicUnit",
		"memberships":     "Membership",
		"materials":       "Material",
		"subjects":        "Subject",
		"units":           "Unit",
		"progress":        "Progress",
	}
	if entity, ok := entityMap[tableName]; ok {
		return entity
	}
	// Default: singular CamelCase
	return strings.TrimSuffix(toCamelCase(tableName), "s")
}

func (g *DatasetGenerator) generateLoader() error {
	// Generar un archivo loader por tabla
	for tableName, tableData := range g.tables {
		if err := g.generateTableLoader(tableName, tableData); err != nil {
			return err
		}
	}

	// Generar load_all.go
	return g.generateLoadAll()
}

func (g *DatasetGenerator) generateTableLoader(tableName string, tableData *parser.TableData) error {
	var buf bytes.Buffer

	buf.WriteString("// Code generated by mock-generator. DO NOT EDIT.\n\n")
	buf.WriteString("package dataset\n\n")

	entityName := getEntityName(tableName)
	tableCamel := toCamelCase(tableName)

	// Imports necesarios
	buf.WriteString("import (\n")
	buf.WriteString("\t\"time\"\n\n")
	buf.WriteString("\t\"github.com/EduGoGroup/edugo-infrastructure/postgres/entities\"\n")
	buf.WriteString("\t\"github.com/google/uuid\"\n")
	buf.WriteString(")\n\n")

	// Variables para evitar unused imports
	buf.WriteString("var _ = time.Now\n")
	buf.WriteString("var _ = uuid.Nil\n\n")

	buf.WriteString(fmt.Sprintf("func load%s() {\n", tableCamel))

	for _, row := range tableData.Rows {
		buf.WriteString(fmt.Sprintf("\tDB.%s.Add(&entities.%s{\n", tableCamel, entityName))
		for i, col := range tableData.Columns {
			colCamel := columnToFieldName(tableName, col)
			val := formatTypedValue(tableName, col, row[i])
			buf.WriteString(fmt.Sprintf("\t\t%s: %s,\n", colCamel, val))
		}
		buf.WriteString("\t})\n")
	}

	buf.WriteString("}\n")

	filename := filepath.Join(g.outputDir, tableName+"_loader.go")
	return os.WriteFile(filename, buf.Bytes(), 0644)
}

// FieldType representa el tipo de un campo de entidad
type FieldType int

const (
	TypeString FieldType = iota
	TypeStringPtr
	TypeUUID
	TypeUUIDPtr
	TypeInt
	TypeInt64
	TypeBool
	TypeTime
	TypeTimePtr
	TypeBytes
)

// fieldTypeMap contiene el mapeo exacto de cada campo por tabla
var fieldTypeMap = map[string]map[string]FieldType{
	"users": {
		"id":             TypeUUID,
		"email":          TypeString,
		"password_hash":  TypeString,
		"first_name":     TypeString,
		"last_name":      TypeString,
		"role":           TypeString,
		"is_active":      TypeBool,
		"email_verified": TypeBool,
		"created_at":     TypeTime,
		"updated_at":     TypeTime,
		"deleted_at":     TypeTimePtr,
	},
	"schools": {
		"id":                TypeUUID,
		"name":              TypeString,
		"code":              TypeString,
		"address":           TypeStringPtr,
		"city":              TypeStringPtr,
		"country":           TypeString,
		"phone":             TypeStringPtr,
		"email":             TypeStringPtr,
		"metadata":          TypeBytes,
		"is_active":         TypeBool,
		"subscription_tier": TypeString,
		"max_teachers":      TypeInt,
		"max_students":      TypeInt,
		"created_at":        TypeTime,
		"updated_at":        TypeTime,
		"deleted_at":        TypeTimePtr,
	},
	"academic_units": {
		"id":             TypeUUID,
		"parent_unit_id": TypeUUIDPtr,
		"school_id":      TypeUUID,
		"name":           TypeString,
		"code":           TypeString,
		"type":           TypeString,
		"description":    TypeStringPtr,
		"level":          TypeStringPtr,
		"academic_year":  TypeInt,
		"metadata":       TypeBytes,
		"is_active":      TypeBool,
		"created_at":     TypeTime,
		"updated_at":     TypeTime,
		"deleted_at":     TypeTimePtr,
	},
	"memberships": {
		"id":               TypeUUID,
		"user_id":          TypeUUID,
		"school_id":        TypeUUID,
		"academic_unit_id": TypeUUIDPtr,
		"role":             TypeString,
		"metadata":         TypeBytes,
		"is_active":        TypeBool,
		"enrolled_at":      TypeTime,
		"withdrawn_at":     TypeTimePtr,
		"created_at":       TypeTime,
		"updated_at":       TypeTime,
	},
	"materials": {
		"id":                       TypeUUID,
		"school_id":                TypeUUID,
		"uploaded_by_teacher_id":   TypeUUID,
		"academic_unit_id":         TypeUUIDPtr,
		"title":                    TypeString,
		"description":              TypeStringPtr,
		"subject":                  TypeStringPtr,
		"grade":                    TypeStringPtr,
		"file_url":                 TypeString,
		"file_type":                TypeString,
		"file_size_bytes":          TypeInt64,
		"status":                   TypeString,
		"processing_started_at":    TypeTimePtr,
		"processing_completed_at":  TypeTimePtr,
		"is_public":                TypeBool,
		"created_at":               TypeTime,
		"updated_at":               TypeTime,
		"deleted_at":               TypeTimePtr,
	},
}

// formatTypedValue formatea un valor según el tipo exacto del campo en la entidad
func formatTypedValue(tableName, colName string, v interface{}) string {
	if v == nil {
		return "nil"
	}

	// Buscar tipo en el mapa
	fieldType := TypeString // default
	if tableFields, ok := fieldTypeMap[tableName]; ok {
		if ft, ok := tableFields[colName]; ok {
			fieldType = ft
		}
	}

	str, isString := v.(string)

	switch fieldType {
	case TypeUUID:
		if isString {
			return fmt.Sprintf(`uuid.MustParse("%s")`, str)
		}
	case TypeUUIDPtr:
		if isString {
			return fmt.Sprintf(`ptrUUID(uuid.MustParse("%s"))`, str)
		}
		return "nil"
	case TypeString:
		if isString {
			escaped := strings.ReplaceAll(str, `"`, `\"`)
			escaped = strings.ReplaceAll(escaped, "\n", `\n`)
			return fmt.Sprintf(`"%s"`, escaped)
		}
	case TypeStringPtr:
		if isString {
			escaped := strings.ReplaceAll(str, `"`, `\"`)
			escaped = strings.ReplaceAll(escaped, "\n", `\n`)
			return fmt.Sprintf(`ptrString("%s")`, escaped)
		}
		return "nil"
	case TypeInt:
		if isString {
			return str // asume que viene como string numérico
		}
		return fmt.Sprintf("%v", v)
	case TypeInt64:
		if isString {
			return str
		}
		return fmt.Sprintf("%v", v)
	case TypeBool:
		if isString {
			return str // "true" o "false"
		}
		if b, ok := v.(bool); ok {
			return fmt.Sprintf("%t", b)
		}
	case TypeTime:
		return "time.Now()"
	case TypeTimePtr:
		return "nil"
	case TypeBytes:
		if isString && str == "{}" {
			return "[]byte(`{}`)"
		}
		if isString {
			return fmt.Sprintf("[]byte(`%s`)", str)
		}
		return "nil"
	}

	// Default: string
	if isString {
		escaped := strings.ReplaceAll(str, `"`, `\"`)
		escaped = strings.ReplaceAll(escaped, "\n", `\n`)
		return fmt.Sprintf(`"%s"`, escaped)
	}
	return fmt.Sprintf(`"%v"`, v)
}

func (g *DatasetGenerator) generateLoadAll() error {
	var buf bytes.Buffer

	buf.WriteString("// Code generated by mock-generator. DO NOT EDIT.\n\n")
	buf.WriteString("package dataset\n\n")
	buf.WriteString("func LoadAllData() {\n")

	// Ordenar tablas para consistencia
	tableNames := make([]string, 0, len(g.tables))
	for name := range g.tables {
		tableNames = append(tableNames, name)
	}
	sort.Strings(tableNames)

	for _, name := range tableNames {
		buf.WriteString(fmt.Sprintf("\tload%s()\n", toCamelCase(name)))
	}

	buf.WriteString("}\n")

	filename := filepath.Join(g.outputDir, "load_all.go")
	return os.WriteFile(filename, buf.Bytes(), 0644)
}

func (g *DatasetGenerator) formatCode() error {
	files, err := filepath.Glob(filepath.Join(g.outputDir, "*.go"))
	if err != nil {
		return err
	}

	for _, file := range files {
		cmd := exec.Command("gofmt", "-w", file)
		if err := cmd.Run(); err != nil {
			// Ignorar errores de formato
			continue
		}
	}

	return nil
}

// Helpers

func (g *DatasetGenerator) getTableNames() []struct{ Name string } {
	names := make([]struct{ Name string }, 0, len(g.tables))

	// Ordenar para consistencia
	tableNames := make([]string, 0, len(g.tables))
	for name := range g.tables {
		tableNames = append(tableNames, name)
	}
	sort.Strings(tableNames)

	for _, name := range tableNames {
		names = append(names, struct{ Name string }{
			Name: toCamelCase(name),
		})
	}
	return names
}

// columnToFieldName convierte nombre de columna SQL al nombre de campo Go en la entidad
func columnToFieldName(tableName, colName string) string {
	// Mapeo específico por tabla para nombres que no siguen convención simple
	tableFieldMap := map[string]map[string]string{
		"academic_units": {
			"parent_unit_id": "ParentUnitID",
		},
		"materials": {
			"file_url": "FileURL",
		},
	}

	// Buscar mapeo específico por tabla
	if tableFields, ok := tableFieldMap[tableName]; ok {
		if fieldName, ok := tableFields[colName]; ok {
			return fieldName
		}
	}

	// Usar mapeo general
	return toCamelCase(colName)
}

func toCamelCase(s string) string {
	if len(s) == 0 {
		return s
	}

	// Mapeo especial para campos que deben ser todo mayúsculas
	specialFields := map[string]string{
		"id":                       "ID",
		"school_id":                "SchoolID",
		"user_id":                  "UserID",
		"parent_id":                "ParentID",
		"teacher_id":               "TeacherID",
		"student_id":               "StudentID",
		"guardian_id":              "GuardianID",
		"material_id":              "MaterialID",
		"unit_id":                  "UnitID",
		"academic_unit_id":         "AcademicUnitID",
		"uploaded_by_teacher_id":   "UploadedByTeacherID",
		"file_url":                 "FileURL",
	}

	if special, ok := specialFields[s]; ok {
		return special
	}

	// Manejar snake_case
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			lower := strings.ToLower(part)
			// Casos especiales
			if lower == "id" {
				parts[i] = "ID"
			} else if lower == "url" {
				parts[i] = "URL"
			} else {
				parts[i] = strings.ToUpper(part[:1]) + part[1:]
			}
		}
	}
	return strings.Join(parts, "")
}

func formatValue(v interface{}) string {
	if v == nil {
		return "nil"
	}

	switch val := v.(type) {
	case string:
		// Funciones SQL especiales
		if val == "NOW()" || val == "UUID()" || val == "CURRENT_DATE()" {
			return fmt.Sprintf(`"%s"`, val)
		}
		// Escapar strings
		escaped := strings.ReplaceAll(val, `"`, `\"`)
		escaped = strings.ReplaceAll(escaped, "\n", `\n`)
		return fmt.Sprintf(`"%s"`, escaped)
	case bool:
		return fmt.Sprintf("%t", val)
	default:
		return fmt.Sprintf(`"%v"`, val)
	}
}
