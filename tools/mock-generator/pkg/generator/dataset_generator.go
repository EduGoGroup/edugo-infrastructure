package generator

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/EduGoGroup/edugo-infrastructure/tools/mock-generator/pkg/parser"
)

type DatasetGenerator struct {
	outputDir string
	tables    map[string]*parser.TableData
}

func NewDatasetGenerator(outputDir string, tables map[string]*parser.TableData) *DatasetGenerator {
	return &DatasetGenerator{
		outputDir: outputDir,
		tables:    tables,
	}
}

func (g *DatasetGenerator) Generate() error {
	// Crear directorio de salida
	if err := os.MkdirAll(g.outputDir, 0755); err != nil {
		return fmt.Errorf("error creando directorio: %w", err)
	}

	// Generar database.go
	if err := g.generateDatabase(); err != nil {
		return fmt.Errorf("error generando database.go: %w", err)
	}

	// Generar tablas
	if err := g.generateTables(); err != nil {
		return fmt.Errorf("error generando tablas: %w", err)
	}

	// Generar loader
	if err := g.generateLoader(); err != nil {
		return fmt.Errorf("error generando loader: %w", err)
	}

	// Formatear código
	if err := g.formatCode(); err != nil {
		fmt.Printf("Warning: no se pudo formatear código: %v\n", err)
	}

	return nil
}

// Templates

const databaseTemplate = `// Code generated by mock-generator. DO NOT EDIT.

package dataset

import "sync"

type MockDatabase struct {
{{- range .Tables }}
	{{ .Name }} *{{ .Name }}Table
{{- end }}
	mu sync.RWMutex
}

var DB *MockDatabase

func init() {
	DB = &MockDatabase{
{{- range .Tables }}
		{{ .Name }}: New{{ .Name }}Table(),
{{- end }}
	}
	LoadAllData()
}
`

const tableTemplate = `// Code generated by mock-generator. DO NOT EDIT.

package dataset

import (
	"sync"

	"github.com/google/uuid"
)

// {{ .TableCamel }}Record representa un registro de {{ .TableName }}
type {{ .TableCamel }}Record struct {
{{- range .Columns }}
	{{ . }} interface{}
{{- end }}
}

type {{ .TableCamel }}Table struct {
	data map[uuid.UUID]*{{ .TableCamel }}Record
	list []*{{ .TableCamel }}Record
	mu   sync.RWMutex
}

func New{{ .TableCamel }}Table() *{{ .TableCamel }}Table {
	return &{{ .TableCamel }}Table{
		data: make(map[uuid.UUID]*{{ .TableCamel }}Record),
		list: make([]*{{ .TableCamel }}Record, 0),
	}
}

func (t *{{ .TableCamel }}Table) Add(record *{{ .TableCamel }}Record) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.list = append(t.list, record)
}

func (t *{{ .TableCamel }}Table) List() []*{{ .TableCamel }}Record {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.list
}

func (t *{{ .TableCamel }}Table) Count() int {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return len(t.list)
}
`

const loaderTemplate = `// Code generated by mock-generator. DO NOT EDIT.

package dataset

func LoadAllData() {
{{- range .Tables }}
	load{{ .Name }}()
{{- end }}
}

{{- range .Tables }}

func load{{ .Name }}() {
{{- range .Rows }}
	DB.{{ $.TableName }}.Add(&{{ $.TableCamel }}Record{
{{- range $i, $col := $.Columns }}
		{{ $col }}: {{ index $.RowValues $i }},
{{- end }}
	})
{{- end }}
}
{{- end }}
`

// Generadores

func (g *DatasetGenerator) generateDatabase() error {
	tmpl, err := template.New("database").Parse(databaseTemplate)
	if err != nil {
		return err
	}

	data := struct {
		Tables []struct{ Name string }
	}{
		Tables: g.getTableNames(),
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return err
	}

	filename := filepath.Join(g.outputDir, "database.go")
	return os.WriteFile(filename, buf.Bytes(), 0644)
}

func (g *DatasetGenerator) generateTables() error {
	for tableName, tableData := range g.tables {
		if err := g.generateTable(tableName, tableData); err != nil {
			return err
		}
	}
	return nil
}

func (g *DatasetGenerator) generateTable(tableName string, tableData *parser.TableData) error {
	tmpl, err := template.New("table").Parse(tableTemplate)
	if err != nil {
		return err
	}

	// Convertir columnas a CamelCase
	columns := make([]string, len(tableData.Columns))
	for i, col := range tableData.Columns {
		columns[i] = toCamelCase(col)
	}

	data := struct {
		TableName  string
		TableCamel string
		Columns    []string
	}{
		TableName:  tableName,
		TableCamel: toCamelCase(tableName),
		Columns:    columns,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return err
	}

	filename := filepath.Join(g.outputDir, tableName+"_table.go")
	return os.WriteFile(filename, buf.Bytes(), 0644)
}

func (g *DatasetGenerator) generateLoader() error {
	// Generar un archivo loader por tabla
	for tableName, tableData := range g.tables {
		if err := g.generateTableLoader(tableName, tableData); err != nil {
			return err
		}
	}

	// Generar load_all.go
	return g.generateLoadAll()
}

func (g *DatasetGenerator) generateTableLoader(tableName string, tableData *parser.TableData) error {
	var buf bytes.Buffer

	buf.WriteString("// Code generated by mock-generator. DO NOT EDIT.\n\n")
	buf.WriteString("package dataset\n\n")

	tableCamel := toCamelCase(tableName)

	buf.WriteString(fmt.Sprintf("func load%s() {\n", tableCamel))

	for _, row := range tableData.Rows {
		buf.WriteString(fmt.Sprintf("\tDB.%s.Add(&%sRecord{\n", tableCamel, tableCamel))
		for i, col := range tableData.Columns {
			colCamel := toCamelCase(col)
			val := formatValue(row[i])
			buf.WriteString(fmt.Sprintf("\t\t%s: %s,\n", colCamel, val))
		}
		buf.WriteString("\t})\n")
	}

	buf.WriteString("}\n")

	filename := filepath.Join(g.outputDir, tableName+"_loader.go")
	return os.WriteFile(filename, buf.Bytes(), 0644)
}

func (g *DatasetGenerator) generateLoadAll() error {
	var buf bytes.Buffer

	buf.WriteString("// Code generated by mock-generator. DO NOT EDIT.\n\n")
	buf.WriteString("package dataset\n\n")
	buf.WriteString("func LoadAllData() {\n")

	// Ordenar tablas para consistencia
	tableNames := make([]string, 0, len(g.tables))
	for name := range g.tables {
		tableNames = append(tableNames, name)
	}
	sort.Strings(tableNames)

	for _, name := range tableNames {
		buf.WriteString(fmt.Sprintf("\tload%s()\n", toCamelCase(name)))
	}

	buf.WriteString("}\n")

	filename := filepath.Join(g.outputDir, "load_all.go")
	return os.WriteFile(filename, buf.Bytes(), 0644)
}

func (g *DatasetGenerator) formatCode() error {
	files, err := filepath.Glob(filepath.Join(g.outputDir, "*.go"))
	if err != nil {
		return err
	}

	for _, file := range files {
		cmd := exec.Command("gofmt", "-w", file)
		if err := cmd.Run(); err != nil {
			// Ignorar errores de formato
			continue
		}
	}

	return nil
}

// Helpers

func (g *DatasetGenerator) getTableNames() []struct{ Name string } {
	names := make([]struct{ Name string }, 0, len(g.tables))

	// Ordenar para consistencia
	tableNames := make([]string, 0, len(g.tables))
	for name := range g.tables {
		tableNames = append(tableNames, name)
	}
	sort.Strings(tableNames)

	for _, name := range tableNames {
		names = append(names, struct{ Name string }{
			Name: toCamelCase(name),
		})
	}
	return names
}

func toCamelCase(s string) string {
	if len(s) == 0 {
		return s
	}

	// Manejar snake_case
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}

func formatValue(v interface{}) string {
	if v == nil {
		return "nil"
	}

	switch val := v.(type) {
	case string:
		// Funciones SQL especiales
		if val == "NOW()" || val == "UUID()" || val == "CURRENT_DATE()" {
			return fmt.Sprintf(`"%s"`, val)
		}
		// Escapar strings
		escaped := strings.ReplaceAll(val, `"`, `\"`)
		escaped = strings.ReplaceAll(escaped, "\n", `\n`)
		return fmt.Sprintf(`"%s"`, escaped)
	case bool:
		return fmt.Sprintf("%t", val)
	default:
		return fmt.Sprintf(`"%v"`, val)
	}
}
